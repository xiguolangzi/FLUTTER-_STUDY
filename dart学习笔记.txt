1.常量构造函数：
	1.1属性必须用final声明；
	1.2函数必须用const声明，属性必须都用final声明；
	1.3调用必须用const调用，否则视为普通函数；
	1.4常量构造函数，没有函数体。
	
2.工厂构造函数：
	2.1工厂构造函数必须用factory声明；
	2.2工厂构造函数不能用this关键字；
	2.3工厂构造函数不能直接实例化；
	2.4单例模式举例：
	class Person(){
		String name;
		//静态属性instance 类型为Person
		static Person instance;
		//工厂构造函数
		factory Person(String name = "刘备"){
			if(Person.instance == null){
				//第一次实例化
				Person.instance = new Person.newSelf(name);
			}else{
				return Person.instance;
			}
		}
	}
	
3.访问修饰符：
	3.1 dart中默认是公开的；
	3.2 下划线为私有(私有属性如果在同一个作用域，不起作用)；
	
4.GET声明的方法：
	4.1 GET声明的方法，不能加()，访问GET方法和访问属性一样
5.SET声明的方法：
	5.1可以通过SET修改属性
	
6.初始化列表
	6.1第一种初始化描述：
	int height;
	int width;
	
	Rect({int height = 2,int width = 10}){
		//需要把初始化参数 赋值 给对应的属性
		this.height = height;
		this.width = width;
		print("${this.height}----${this.width}");
	}
	
	6.2第二种初始化描述
	int height;
	int width;
	
	Rect() : height = 2, width = 10 {
		//不需要赋值属性
		print("${this.height}----${this.width}");
	}
	
	6.3第三种初始化列表的巧妙用法
	class Point{
		duoble x , y, z ;
		
		Point(this.x,this.y,this.z);
		
		//初始化列表的特殊用法
		Point.twoD(this.x,this.y) : this(x ,y , 0);
	}
	
7.static
	7.1静态方法 不能访问 非静态属性；
	7.2静态方法中不能使用 this;
	7.3可以通过 类名称 直接访问 静态属性、静态方法；
	7.4不能通过 实例化对象 去 访问静态属性、静态方法；
	7.5实例化对象 可以通过类里面 非静态方法 引用静态属性、静态方法；
	7.6静态方法作用： 不需要实例化，可以直接通过类引用静态属性和方法，节省开辟空间的资源。
	
8.元数据：
	8.1 元数据，以@开头；
	8.2 @override	#重写
		子类继承父类，子类重写父类同名的方法
		
	8.3 @required	#必填
		用来指示必填参数
		
	8.4 @deprecated	#弃用
		表示当前的类或者方法不再建议使用。
		当前方法可以引用，但是会有删除线标识，不影响使用。
	
9.继承
	9.1 子类通过 extends 关键字 继承父类；
	9.2 私有属性、方法 不能继承；
	9.3 子类可以通过 @override	#标记重写方法；
	9.4 子类通过 super 关键字 引用父类的属性和方法；
		super.say();	#调用父类中的say()方法
		son(String job) : super(job);	#初始化列表，父类传参，子类必须传参，继承普通的构造函数

10.抽象类
	10.1 抽象类 通过 abstract 关键字 修饰的类；
	10.2 抽象类的作用：充当普通类的模板，约定一些属性和方法；
	10.3 普通类中 不可以有 抽象方法；
	10.4 抽象类 不能被实例化(不能new)；
	10.5 抽象类 可以被 普通类继承；
		如果普通类继承了抽象类，就必须实现 抽象类 中的所有抽象方法。
		
11.接口
	11.1 类可以 用 implements 实现多个接口，多个接口用逗号隔开；
	11.2 接口一般为抽象类(相当于一些小零件)；
	11.2 调用接口举例：
	//接口1：抽象类，约定了内核
	abstract class Processor{
		String cores;
		arch(String name)
	}
	//接口2：抽象类，约定了相机
	abstract class Camera{
		String resolution;
		brand(String name)
	}
	
	//手机类：调用接口1、接口2
	class Phone implements Processor,Camera{
		//1.重现接口的所有属性
		@override
		String cores;
		@override
		String resolution;
		//3.构造函数传参
		Phone(this.cores,this.resolution);
		//2.重现接口的所有方法
		@override
		arch(String name){
			print("芯片制程：“ + name);
		}
		@override
		brand(String name){
			print("相机品牌" + name);
		}
	
	}
	
	void main(){
		//具体实例化-得到手机对象
		Phone p = new Phone("4核","3000万");
		//调用手机对应的方法
		p.arch("5nm");
		p.brand("莱卡");
	}
	
12.混入 Mixin
	12.1 混入的两种声明方式：
		class MixinA{.....}
		mixin MixinB{.....}
		
	12.2 混入的作用
		弥补单继承的缺陷，可以提高代码的复用效率；
		普通类可以通过 with 来使用混入
			class MyClass with MixinA,MixinB {.....}
		使用多个混入时，后引入的混入会覆盖之前混入中的重复的内容
			MixinA 和 MixinB 都有 hello()方法，MyClass 会使用 MixinB 中的方法；
	12.3 一旦继承了，就不能用作混入；	
	12.4 用作混入的类，不能拥有构造函数：
		class MixinA{
			String name = "MixinA“；
			MixinA();	//会报错
		}
	12.5 建议使用 Mixin 来声明混入类，不建议使用 class 来声明混入的类。
	
13.泛型
	13.1 泛型函数（约定参数类型、约定返回值类型）
	T getData<T>(T value){
		return value;
	}
	
	13.2 泛型函数（只约定参数类型、不约定返回值类型）
	getData<T>(T value){
		return value;
	}
	
	void main (){
	
		print(getData<int>(20));
		print(getData<String>("你好"));
	
	}
	
	13.3 泛型类
	
	13.4 泛型接口
	//接口1：抽象类，约定了内核
	abstract class Processor<T>{
		String cores;
		arch(String name)
	}
	//接口2：抽象类，约定了相机
	abstract class Camera<T>{
		String resolution;
		brand(String name)
	}
	
	//手机类：调用接口1、接口2
	class Phone<T> implements Processor<T>,Camera<T>{
		//1.重现接口的所有属性
		@override
		String cores;
		@override
		String resolution;
		//3.构造函数传参
		Phone(this.cores,this.resolution);
		//2.重现接口的所有方法
		@override
		arch(String name){
			print("芯片制程：“ + name);
		}
		@override
		brand(String name){
			print("相机品牌" + name);
		}
		
14.枚举
	14.1 枚举通过 enum 关键字声明
	14.2 枚举格式：
		enum Color {red , green ,blue}
	14.3 枚举是数量固定的常量值（有限数量的常量）
	14.4 获取枚举列表
		List<color>colors1 = Color.values;
		colors2 = Color.values;
	14.5 可以 通过 index  获取枚举值得索引
		assert(Color.green.index == 1);
		print(colors1[0])
		colors1.forEach((element){ print("value = $element,  index = ${element.index}")})
		
15.库与生态
	15.1 dart库 ：https://pub.dev    库管理：pubspec.yaml   管理命令：pub
	
	15.2自定义库
		15.2.1声明库：通过 library 来生明自定义库；
		15.2.2 library 关键字声明的库名称建议使用：小写字母+下划线，驼峰在flutter中会报错
		15.2.3 通过 import 来引用
		15.2.4 举例：
		# 声明 定义自定义库
		library my_custom；
		
		class MyCustom{
			String name = "MyCustom";
			static num version = 1.0
			
			void info(){
			   print("我是自定义库")；
			}
		}
		#引用自定义库
		import "./MyCustom"
		
	15.3 系统库
		15.3.1引入系统库
			import "dart:math"
		
	15.4 引入部分库
		15.4.1 包含引入 show ，show 后面表示包含引用的内容
		common.dart
			void f1(){
				print("f1");
			}
			
			void f2(){
				print("f1");
			}
			
			void f3(){
				print("f1");
			}
		
		import "./common.dart" show f1,f3;
		
		void main(){
			f1();
			f2();  #报错，因为f2没有在show后面绑定，所有找不到
			f3();
		}
		
		
		
		15.4.2 排除引入 hide ， hide 后面表示隐藏引用的内容
		import "./common.dart" hide f1,f3;
		
		void main(){
			f1();   #报错，因为f1在hide后面被隐藏，所有找不到
			f2();  
			f3();   #报错，因为f3在hide后面被隐藏，所有找不到
		}
		
	15.5 延迟引入
		15.5.1 延迟引入关键字 deferred ,延迟引入只是代表关联关系，并没有真正的加载，加载需要 loadlibrary() 方法
		15.5.2 举例说明：
			impor "./common.dart" deferred as fun;
			
			void main(){
				f1;  #报错，fun没有加载
			}
	
		15.5.3 使用方法举例：
			impor "./common.dart" deferred as fun;
			
			#future ... async { 异步类}，返回future
			future great() async {
				# await 异步等待执行，loadlibrary() 加载fun库
				await fun.loadlibrary();
				fun.f1;
			}
			
			void main(){
				print("1");
				# great 为异步调用
				great();
				print("2");
				print("3");
			}

	15.6 part 与 part of
		15.6.1 作用：分库 组合成 主库 ,引入主库，可以同时实例化分库中的方法
		15.6.2 举例：
			####### 主库
			library phone
			
			#与分库建立联系
			part "Camera.dart";
			part "pubspec.dart";
			
			
			
			####### 分库1
			part of phone; #主库phone的一部分
			
			class Camera{
				String name = "摄像头"；
				
				void info(){
					print("我是摄像头")
				}
			}
			
			####### 分库2
			part of phone; #主库phone的一部分
			
			class pubspec{
				String name = "处理器"；
				
				void info(){
					print("我是处理器")
				}
			}
			
16 扩展 extension
	16.1 扩展的作用
		可以扩展类的功能
	16.2 举例：
		class Person{
			say (){
				print("hello word");
			}
		}
		
		#扩展Preson类
		extension studentPerson on Person{
			study(){
				print("study hard");
			}
		}
		
		#引用扩展内容
		void main(){
			s = Person.study();
			print(s);
		}
		
17. call 
	17.1 call 方法，就是类可以当做函数一样使用
	17.2 举例：
	 class function{
		fun(){
			print("123456")
		}
		# call 方法
		call(String num){
			print("654321")
		}
	 }
	 
	 void main(){
		# 实例化
		var p = function();
		#直接传参调用call 方法
		p("911");
	 }
	 
18.noSuchMethod 
	18.1 作用：调用类没有的方法，给出特殊提示；
	18.2 举例：
	class Person {
		say(){
			print("Say something")
		}
		@override
		noSuchMethod(Invocation invocation){
			print("未定义的方法")；
			return super.noSuchMethod(invocation);
		}
	}
	
	void main(){
		#调用不存在的方法需要dynamic类型来实例化
		dynamic p = Person();
		print(p.say());
		print(p.stuty()); #会抛出noSuchMethod给出的特殊错误提示。
	
	}
	
19.hashCode 
	19.1 hashCode是dart对象的唯一标识，表现为一串数字；
	19.2 可以通过.hashCode 来获取hashCode的值
	
20.typedef 声明类型（别名类型）
	20.1 声明类型（别名类型）
	typedef mathtype (int a , int b);
	这样 a,b 的类型都是 mathtype，也都是 int!
	
21.单线程
	21.1 单线程包括：
		主线程(调用栈)、微任务(微任务队列)、宏任务(时间队列)
		
22.Isolate 多线程
	22.1 多线程是以隔离的方式存在，互补影响，使用完自动释放，不会出现死锁现象；
	
	22.2 线程方法
		Isolate.spawn()		#创建线程
		
		Isolate.spawnUri()	#创建线程
		
		Isolate.pause()		#暂停线程
		
		Isolate.kill()		#杀死线程
	22.3 举例：
		#引入线程库
		import "dart:isolate";
		
		void main(){
			multiThread();
		}
		void multiThread(){
			print("multiThread start");
			
			#打印当前主线程
			print("当前的线程是："+Isolate.current.debugName);
			
			#创建线程单向接收
			ReceivePort r1 = ReceivePort();
			#创建线程单向发送
			SendPort p1 = r1.sendPort;
			
			#创建新线程
			Isolate.spawn(newThread,p1);
			
			#监听新线程发送的消息
			r1.listen((msg){
				print("来自新线程的消息：" + msg.toString());
				r1.close;
			})
			
			print("multiThread end");
		}
		
		void newThread(SendPort p1){
			print("新线程的线程是："+Isolate.current.debugName)；
			p1.send("新线程发送的消息123")
		}
		
	22.4 封装发送消息函数
		Future sendToReceive(SendPort port,msg){
			print("发送消息给新线程" + msg.toString);
			ReceivePort response = ReceivePort();
			port.send([msg,response.sendPort]);
			return response.first;
		}
		
23 Future 异步处理
	23.1 Future 有三种状态：
		未完成	（Uncompleted）
		已完成，并返回数据	（completed with data）
		已完成，但返回报错	（completed with error）
		
	23.2 创建 Future 实例化
		void main(){
			#1.实例化
			final f = Future((){
				print("Create the future");
				return 132;
			})
			#2.返回值
			f.then((value)=> print(value));
			print("Done with main");
		}
		
	23.3 延迟
		void main(){
			Future.delayed(
				#延迟时间
				Duration(seconds: 2 ),
				#异步回调函数
				(){
					return 123;
				}
			#返回结果 .then	
			).then((value){
				#返回结果处理函数
				print(value);
			#返回报错信息
			}).catchError((err){
				print(err);
			},test:(error)=>error.runtimeType == String,
			#调用完成后的收尾工作(不管错误与否，结束后必须返回的处理)
			).whenComplete(
				(){
				print("All Completed");
				}
			)
		}
		
	23.4 执行顺序
		Future(回调函数) 	#默认是异步任务，会被丢到事件队列(event queue)中的所有抽象方法。
		Future.sync(回调函数) 	#同步任务，同步执行，不会被丢到异步队列中；
		Future.microtask(回调函数) 	#会被丢到微任务中，优先级高于事件队列；
		Future.value("Future.value").then((value)=>print(value));  #value里面的值是常量，相当于微任务
		
	23.5 多任务
		23.5.1 Future.any(futures)
			返回最先完成的结果，其他任务抛弃
			main(){
				print("start");
				
				Future.any([
					Future.delayed(Duration(seconds:4)).then((value){print("future 4"); return 4}),
					Future.delayed(Duration(seconds:2)).then((value){print("future 2"); return 2}),
					Future.delayed(Duration(seconds:3)).then((value){print("future 3"); return 3}),
				]).then((value)=>print("多个任务执行的结果是：" + value.toString())) #返回的结果是最快的 future 2
				
				print("end");			
			}
		
		23.5.2 Future.wait(futures)
			等所有都执行完成后，返回所有结果
			main(){
				print("start");
				
				Future.wait([
					Future.delayed(Duration(seconds:4)).then((value){print("future 4"); return 4}),
					Future.delayed(Duration(seconds:2)).then((value){print("future 2"); return 2}),
					Future.delayed(Duration(seconds:3)).then((value){print("future 3"); return 3}),
				]).then((value)=>print("多个任务执行的结果是：" + value.toString())) #返回的结果是所有结果的列表
				
				print("end");			
			}
		
		23.5.3 Future.doWhile()
		
		
		23.5.4 Future.ForEach()
			main(){
				Future.forEach(
					[1,2,3],(element){
						return Future.delayed(Duration(seconds : 2),(){
							print("当前元素：$element");
							return element.toString() + "_AAA";
						}).then((value){
							print("最后的结果是：" + value);
						})
					}
				)
			}
	
	23.6 FutureBuilder
		23.6.1 FutureBuilder 是一个类，需要引入三方库： import"package:flutter/material.dart"
		23.6.2 FutureBuilder 中有三个属性
			future
			initialData
			builder(context,snapshot)
				snapshot.connectionState	#链接状态
					ConnectionState.none	#未链接
					ConnectionState.waiting	#已连接等待交互
					ConnectionState.active	#正在交互
					ConnectionState.done	#异步任务完成
				snapshot.hasData
					snapshot.data	#成功返回数据
				snapshot.hasError
				
		23.6.3 举例：
		FutureBuilder(
			future: getData, # 调用 future 函数
			builder:(context,snapshot){
				swich(snapshot.connectionState){
					case ConnectionState.none:
					case ConnectionState.waiting:
					case ConnectionState.active:
						print("waiting");
						return null;
					case ConnectionState.done:
						if(snapshot.hasError){
							print("error");
							return null;
						}else{
							print("done");
							return snapshot.data;
						}
				}
			return Text("aaa");
			}
		);
		
24 Stream
	24.1 Dart 中的异步数据流，可以连续返回多个值；
	24.2 Future 只能返回一个值；
	24.3 Stream 相关的API
		listen	#数据监听
		error	#接受失败状态
		done	#接受结束状态
		
	24.4 Stream 类型
		Single-Subscription	#单一订阅
			只能listen一次
			
		Broadcast	#广播
			可以被监听多次
	24.5 Stream.fromFuture
		Future<String>getData(){
			return Future.delayed(Duration(seconds : 2),(){
				return "当前时间：${DateTime.now()}";
			})
		}
		
		main(){
			Stream.fromFuture(getData())
			.listen((event){print("Stream.fromFuture: $event");})
			.onDone((){print("Stream.fromFuture done");});
		}
		
	24.6 Stream.fromFutures
		Future<String>getData(){
			return Future.delayed(Duration(seconds : 2),(){
				return "当前时间：${DateTime.now()}";
			})
		}
		
		main(){
			var data = [getData(),getData(),getData(),getData()]
			Stream.fromFutures(data)
			.listen((event){print("Stream.fromFutures: $event");})
			.onDone((){print("Stream.fromFutures done");});
		}
		
	24.7 Stream.fromIterable 遍历
		Future<String>getData(){
			return Future.delayed(Duration(seconds : 2),(){
				return "当前时间：${DateTime.now()}";
			})
		}
		
		main(){
			var data = [1,2，“hello”,true,null]
			Stream.fromIterable(data)
			.listen((event){print("Stream.fromIterable: $event");})
			.onDone((){print("Stream.fromIterable done");});
		}
		
	24.8 Stream.periodic 指定时间执行指定的操作
		main(){
			Duration interval = Duration(seconds:1);
			
			#如果不设置periodic 第二个参数，结果返回null
			Stream<int> stream = Stream<int>.periodic(interval);
			stream.listen((event){
				print("stream.periodic: $event")；
			}).onDone((){
				print("Stream.periodic done")；
			})
			
			#设置periodic 第二个参数,则返回具体的数据
			Stream<int> stream = Stream<int>.periodic(interval,(data)=>data);
			#不截断会一直不停输出
			stream.listen((event){
				print("stream.periodic: $event")；
			}).onDone((){
				print("Stream.periodic done")；
			})
			
			#设置periodic 第二个参数,则返回具体的数据
			Stream<int> stream = Stream<int>.periodic(interval,(data)=>data);
			#终止数据流,take(5)只拿5条数据，执行到第六条时终止
			stream.take(5).listen((event){
				print("stream.periodic: $event")；
			}).onDone((){
				print("Stream.periodic done")；
			})
		
		}
		
	24.9 API操作 Stream
		24.9.1 take(5) / takeWhile()
		Stream<int> stream = Stream<int>.periodic(interval,(data)=>data);
			#终止数据流,take(5)只拿5条数据，执行到第六条时终止
			stream.take(5).listen((event){ 
				print("stream.periodic: $event")；
			}).onDone((){
				print("Stream.periodic done")；
			})
		
		24.9.2 where() #条件过滤
		
		24.9.3 distinct()	#去掉连续重复的值
		
		24.9.4 skip(2) / skipWhile()	#跳过最前面的2个数据
		
		29.9.5 map()
			Stream<int> streamData = Stream<int>.periodic(interval,(data)=>data+1);
			
			streamData.takeWhile((element){
				return element <= 3;
			}).map((event){
				print(" map -> $event -> ${event*100}");
				return event*100;
			}).listen((event){
				print(" listen -> $event");
			}).onDone((){
				print("Done 结束");
			})
		
		29.9.6 toSet() / toList() / toString()
		
		29.9.7 length / first / last
		
	24.10 StreamBuilder 在FLUTTER环境的一个类
		
		
		
25 Async / Await
	Async	#标记函数是一个异步函数，其返回值类型为Future
	Await	#等待某个异步方法执行完毕
		用来等待耗时操作的返回结果，这个操作会阻塞后面的代码
			
	25.1 Await 的作用：等待执行
		test(){
			return Future.delayed(Duration(seconds:2),(){
				print("Future.delayed");
				return 123;
			})
		}
		
		main() async{
			print("start");
			
			#等待 test 执行完，才执行end
			await test();
			
			print("end");
		}
	25.2 异步函数改造
		getUserInfo(){
			return Future.delayed(Duration(seconds:2),(){
				print("UserInfo");
				return 1;
			})
		}
		
		getOrderInfo(){
			getUserInfo().then((value){
				print("用户信息：$val");
			})
		}
		
		getOrderInfo() async{
			var id = await getUserInfo();
			print(id);
			})
		}
		
		
26 Generator 生成器
	26.1 同步生成器（stnc + yield）
		-- 使用sync*,返回的是 Iterable 对象；
		-- yield 会返回 moveNext 为 ture , 并等待 moveNext 指令；
		-- yield = return + continue
		
		main(){
			# 返回是可迭代的内容 iterator<int>
			var res = getNumber(5).iterator;
			#res.moveNext(); print(res.current);	#结果是0
			#res.moveNext(); print(res.current);	#结果是1
			#res.moveNext(); print(res.current);	#结果是2
			
			while(res.moveNext()){
				print(res.current);
			}
		
		}
		
		#声明同步生成器函数 sync*
		getNumber(int n) sync* {
			print("start");
			
			int i =0;
			while (i<n){
				#返回
				yield i++
			}
			
			print("end");
		}
	26.2 异步生成器
		
		main(){
			# 返回的是数据流 Stream<int>
			final Stream<int> s = asyncCountDown(5);
			
			print("start");
			
			s.listen((event){
				print(event);	#结果是：5 4 3 2 1 
			}).onDone((){
				print("Done");
			})
			
			print("end");
		}
		
		#声明异步生成器函数 async*
		Stream<int> asyncCountDown(int n) async* {
			while(n>0){
				yield n--;
			}
		}
		
	26.3 递归生成器
		main(){
			final Iterable<int> s = getRange(1,6);
			print("start");
			s.forEach(element){
				print(element);
			})
			print("end");
		}
		
		
		Iterable<int>getRange(int start,int end) sync* {
			if(start <= end){
				yield start;
				#实现递归调用-方式1 for
				for (final val in getRange(start+1,end)){
					yield val;
				#循环遍历返回-方式2 yield*
				yield* getRange(start+1,end);
					
				}
			}
		}